#
# Integrated QE bandstructure calculation
# - Read TOML & Write both SCF and BAND input files
#

import os, sys
from re import A
import ase.io as io
from ase.data import atomic_masses
import ase.io as io
import tomli, json
import numpy as np
import argparse


parser = argparse.ArgumentParser(
    description=" Integrated QE bandstructure calculation - Read TOML & Write both SCF and BAND input files"
)
parser.add_argument("-i", "--inp", help="TOML(input parameter)")
parser.add_argument("-x", "--xsf", help="XSF(internal XCrySDen structure format)")

args = parser.parse_args()

if not args.inp:
    raise Exception("Please enter the toml file path (--inp [filepath])")

if not args.xsf:
    raise Exception("Please enter the xsf file path (--xsf [filepath])")

try:
    os.environ["PROGRAM_HOME"]
except:
    raise KeyError(
        "Please set the PROGRAM_HOME environment variable. (ex: export PROGRAM_HOME=[DirPath])"
    )

PSEUDODIR_PZ = "%s/datas/UPF_PZ" % os.environ["PROGRAM_HOME"]
PSEUDODIR_PBE = "%s/datas/UPF_PBE" % os.environ["PROGRAM_HOME"]

usage = "$ %s [TOML input file] [ASE-readable structure file]\n" % sys.argv[0]
print("usage : \n", usage)


#
# Read XSF (generated by crystalViewer or upload, ...)
#
atoms = io.read(args.xsf)
print("Reading %s [structure file] ..." % args.xsf)
cell = atoms.get_cell()
positions = atoms.get_positions()
symbols = atoms.get_chemical_symbols()
unique_symbols = list(set(symbols))
masses = atomic_masses[list(set(atoms.get_atomic_numbers()))]

#
# Read TOML input file
#
param_TOML = tomli.load(open(args.inp, "rb"))
print("Reading %s [TOML input file] ..." % args.inp)

# In TOML all options are included in a group.
print("\n%-40s%-40s" % ("Key", "Value"))
print("=" * 80)
for key, value in param_TOML.items():
    for key1, value1 in value.items():
        print("%-20s%-20s%-40s" % (key, key1, value1))

#
# Write QE input files (1 & 2 for pw.x) / simulation_1 & simulation_2
#
input_file_1 = open("simulation_1.txt", "w")
input_file_2 = open("simulation_2.txt", "w")


def write_line_to_2f(line):
    for f in [input_file_1, input_file_2]:
        f.write(line)


input_file_3 = open("simulation_3.txt", "w")

#
# &CONTROL
#
calculation = "scf"  # 'scf' or 'bands'
pseudo_dir = "./"  # FIXED
restart_mode = "from_scratch"  # FIXED
prefix = "QESim"  # FIXED

#
# TODO: &IONS
#
ion_dynamics = "bfgs"
ion_temperature = "rescaling"
tempw = 300
tolp = 10

TODO_LATER = """if param_TOML['SETUP']['job_type'] == 'geometry_optimization':
    input_file_1.write("ion_dynamics = %s\n" % ion_dynamics)
    
if param_TOML['SETUP']['job_type'] == 'molecular_dynamics':
    ion_dynamics = 'verlet'
    input_file_1.write("ion_dynamics = %s\n"    % ion_dynamics)
    input_file_1.write("ion_temperature = %s\n" % ion_temperature)
    input_file_1.write("tempw = %s\n"           % tempw)
    input_file_1.write("tolp = %s\n"            % tolp)"""

# write
write_line_to_2f("&CONTROL\n")
input_file_1.write("calculation = '%s'\n" % calculation)
input_file_2.write("calculation = '%s'\n" % "bands")
write_line_to_2f("pseudo_dir = '%s'\n" % pseudo_dir)
write_line_to_2f("restart_mode = '%s'\n" % restart_mode)
write_line_to_2f("prefix = '%s'\n" % prefix)
write_line_to_2f("/\n")

#
# &SYSTEM
#
nat = len(atoms)  # AUTO
ntyp = len(unique_symbols)  # AUTO
ecutwfc = param_TOML["SYSTEM"]["ecutwfc"]
ecutrho = 4 * ecutwfc
degauss = 0.002
ibrav = 0
nosym = ".TRUE."
input_dft = param_TOML["SYSTEM"]["input_dft"]
nbnd = param_TOML["SYSTEM"]["nbnd"]

# write
write_line_to_2f("&SYSTEM\n")
write_line_to_2f("nat = %i\n" % nat)
write_line_to_2f("ntyp = %i\n" % ntyp)
write_line_to_2f("ecutwfc = %s\n" % ecutwfc)  # FROM UI TOML
write_line_to_2f("ecutrho = %s\n" % ecutrho)  # FROM UI TOML
write_line_to_2f("degauss = %s\n" % degauss)  # FROM UI TOML
write_line_to_2f("ibrav = %s\n" % ibrav)  # FIXED
write_line_to_2f("nosym = %s\n" % nosym)  # FIXED

input_file_2.write("nbnd = %i\n" % nbnd)

write_line_to_2f("/\n")

#
# &ELECTRONS
#
conv_thr = 1e-06
electron_maxstep = 200
mixing_beta = 0.1
mixing_mode = "plain"
scf_must_converge = ".TRUE."
startingwfc = "atomic+random"

# write
write_line_to_2f("&ELECTRONS\n")
write_line_to_2f("conv_thr = %s\n" % conv_thr)
write_line_to_2f("electron_maxstep = %s\n" % electron_maxstep)
write_line_to_2f("mixing_beta = %s\n" % mixing_beta)
write_line_to_2f("mixing_mode = '%s'\n" % mixing_mode)
write_line_to_2f("scf_must_converge = %s\n" % scf_must_converge)
write_line_to_2f("startingwfc = '%s'\n" % startingwfc)
write_line_to_2f("/\n")

#
# ATOMIC_SPECIES (depends on the XSF file)
#
i_species = 0
list_species = []
for symb in unique_symbols:
    list_species.append([symb, masses[i_species], "%s.UPF" % symb])
    i_species += 1

# write
write_line_to_2f("ATOMIC_SPECIES\n")
for symb, mass, pseudo in list_species:
    write_line_to_2f("%-3s %5.3f %s\n" % (symb, mass, pseudo))
    if input_dft == "PZ":
        print("Get PS in PSEUDODIR_PZ...")
        os.system("cp %s/%s.UPF ." % (PSEUDODIR_PZ, symb))
    elif input_dft == "PBE":
        print("Get PS in PSEUDODIR_PBE...")
        os.system("cp %s/%s.UPF ." % (PSEUDODIR_PBE, symb))
    else:
        print("Invalid XC: %s" % input_dft)

#
# CELL_PARAMETERS (depends on the XSF file)
#
write_line_to_2f("CELL_PARAMETERS {angstrom}\n")
write_line_to_2f("  %14.12f %14.12f %14.12f\n" % tuple(cell[0]))
write_line_to_2f("  %14.12f %14.12f %14.12f\n" % tuple(cell[1]))
write_line_to_2f("  %14.12f %14.12f %14.12f\n" % tuple(cell[2]))

#
# ATOMIC_POSITIONS (depends on the XSF file)
#
write_line_to_2f("ATOMIC_POSITIONS {angstrom}\n")
i_position = 0
for x, y, z in positions:
    write_line_to_2f("%-3s %9.6f %9.6f %9.6f\n" % (symbols[i_position], x, y, z))
    i_position += 1

#
# K_POINTS {automatic} : For SCF run / simulation_1
#
kpoints = [7, 7, 7, 1, 1, 1]  # FROM UI TOML
nk1 = param_TOML["K_POINTS_automatic"]["nk1"]
nk2 = param_TOML["K_POINTS_automatic"]["nk2"]
nk3 = param_TOML["K_POINTS_automatic"]["nk3"]
sk1 = param_TOML["K_POINTS_automatic"]["sk1"]
sk2 = param_TOML["K_POINTS_automatic"]["sk2"]
sk3 = param_TOML["K_POINTS_automatic"]["sk3"]
kpoints = [nk1, nk2, nk3, sk1, sk2, sk3]
input_file_1.write("K_POINTS {automatic}\n")
input_file_1.write("%3i %3i %3i %3i %3i %3i\n" % tuple(kpoints))

#
# K_POINTS {crystal} : For bandstructure / simulation_2
#
npoints = param_TOML["SETUP"]["npoints"]
path = param_TOML["SETUP"]["path"]

bpath = atoms.cell.bandpath(path=path).interpolate(npoints=npoints)

frac_coords = bpath.kpts.copy()  # fractional coordinates
cart_coords = bpath.cartesian_kpts()  # cartesian coordinates
# xcoords : x-values
# special_xcoords & labels : positions of vertical lines and the coresponding labels
xcoords, special_xcoords, labels = bpath.get_linear_kpoint_axis()

print("\nBandstructure plot details")
print("=" * 80)
print("x-coords\n", bpath[0], "\n")
print("special_xcoords\n", bpath[1], "\n")
print("labels\n", bpath[2], "\n")

# Rewrite the positions of special kpoints in the unit of "2*Pi/a",
# valid only in case of a=b=c ...
factor = 2 * np.pi / atoms.cell.cellpar()[0]
special_xcoords /= factor

# add serial numbers
kpt_list = []
i = 1
for kx, ky, kz in frac_coords:
    kpt_list.append([kx, ky, kz, i])
    i += 1

input_file_2.write("K_POINTS {crystal}\n")
input_file_2.write("%i\n" % len(kpt_list))
for kx, ky, kz, i in kpt_list:
    input_file_2.write(
        "%15.12f %15.12f %15.12f %4i\n" % (float(kx), float(ky), float(kz), i)
    )

#
# Save information on special kpoints (for post-process)
#
dict_kpath = {}
dict_kpath["special_xcoords"] = list(special_xcoords)
dict_kpath["labels"] = list(labels)
with open("json_kpath.json", "w") as outfile:
    json.dump(dict_kpath, outfile)

#
# input file (3) for bands.x / simulation_3
#
input_file_3.write("&BANDS\n")
input_file_3.write("prefix = '%s'\n" % prefix)
input_file_3.write("lsym = .FALSE.\n")
input_file_3.write("/\n")

#
# Write QE input files
#
input_file_1.close()
input_file_2.close()
input_file_3.close()
